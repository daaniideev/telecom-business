# Databricks notebook source
# MAGIC %md **First, we insert the data:**

# COMMAND ----------

columns = ['id_cliente','nombre','edad','sexo','provincia','pais']
data = [(1,'Pablo Perez',26,'M','Madrid','España'),(2,'Eduardo Redondo',58,'M','Bogota','Colombia'),(3,'Roberto Salazar',68,'M','Monterrey','Mexico'),
        (4,'Pedro Conde',32,'M','Madrid','España'),(5,'Ana Robles',41,'F','Valladolid','España'),(6,'David Roldan',74,'M','Guadalajara','Mexico'),
        (7,'Carmen Arauzo',19,'F','Medellin','Colombia'),(8,'Silvia Rodriguez',49,'F','Barcelona','España'),(9,'David Cardoso',24,'M','Cali','Colombia'),
        (10,'Pablo Lopez',40,'M','Sevilla','España'),(11,'Luis Rodrigues',20,'M','Bogota','Colombia'),(12,'Alvaro Monroy',75,'M','Monterrey','Mexico'),
        (13,'Victor Ruiz',53,'M','Valladolid','España'),(14,'Melisa Aguado',30,'F','Bogota','Colombia'),(15,'Cristian Cuadrado',52,'M','Guadalajara','Mexico'),
        (16,'Cristina Sanz',49,'F','Madrid','España'),(17,'Jorge Recio',18,'M','Valladolid','España'),(18,'Laura Luiz',44,'F','Cali','Colombia'),
        (19,'Juan Carlos Iglesias',38,'M','Barcelona','España'),(20,'Oscar Rico',22,'M','Valladolid','España'),(21,'Fatima Cuevas',29,'F','Cali','Colombia'),
        (22,'Clara Suarez',21,'F','Sevilla','España'),(23,'Fernanda Gomez',78,'F','Monterrey','Mexico'),(24,'Ruben Garcia',68,'M','Sevilla','España'),
        (25,'Ines Barcero',29,'F','Guadalajara','Mexico'),(26,'Celia Castro',47,'F','Barcelona','España'),(27,'Roberta Varado',64,'F','Cali','Colombia'),
        (28,'Walter Ramos',54,'M','Cali','Colombia'),(29,'Romina Verde',29,'F','Guadalajara','Mexico'),(30,'Marta Rodrigo',67,'F','Guadalajara','Mexico')]
 
df_clientes = spark.createDataFrame(data, columns)
df_clientes.write.mode("overwrite").option("encoding", "UTF-8").saveAsTable('df_clientes')
 # Se presentan 10 tipos de ofertas diferentes (combinaciones entre Fibra Optica, Fijo, Movil (llamadas o mensajes ilimitados), Television)
 
columns = ['id_oferta','descripcion','importe'] 
data = [(1,'Fibra Optica 300MB + Fijo ilimitado + Television',70.00),
        (2,'Fibra Optica 600MB + Fijo ilimitado + Television', 78.50),
        (3,'Fibra Optica 300MB + Movil llamadas y datos ilimitados + Television', 85.00),
        (4,'Fibra Optica 600MB + Movil llamadas y datos ilimitados + Television', 95.00),
        (5,'Fibra Optica 300MB + Fijo ilimitado + Movil llamadas y datos ilimitados', 102.50),
        (6,'Fibra Optica 600MB + Fijo ilimitado + Movil llamadas y datos ilimitados + Television', 124.50),
        (7,'Fibra Optica 300MB + Movil llamadas ilimitadas + Television', 80.50),
        (8,'Fibra Optica 300MB + Movil datos ilimitados + Television', 84.00),
        (9,'Fijo llamadas ilimitadas + Movil llamadas y datos ilimitados', 42.50),
        (10,'Fijo llamadas ilimitadas + Movil llamadas ilimitadas', 31.99)]
 
df_ofertas = spark.createDataFrame(data, columns)
df_ofertas.write.mode("overwrite").option("encoding", "UTF-8").saveAsTable('df_ofertas');
 
columns = ['id_cliente','id_oferta','importe','fecha'] 
data = [(1,6,124.5,"2020-07-31"),(1,6,118.60,"2020-07-31"),(1,9,36.5,"2020-07-31"),
        (2,4,95.0,"2020-07-31"),(3,5,102.5,"2020-07-31"),(5,7,80.5,"2020-07-31"),
        (5,9,40.5,"2020-07-31"),(6,8,84.0,"2020-07-31"),(7,4,95.0,"2020-07-31"),
        (8,5,102.5,"2020-07-31"),(10,6,124.5,"2020-07-31"),(11,3,80.0,"2020-07-31"),
        (12,1,70.0,"2020-07-31"),(13,4,95.0,"2020-07-31"),(14,9,42.5,"2020-07-31"),
        (15,2,78.50,"2020-07-31"),(15,6,115.0,"2020-07-31"),(16,1,70.0,"2020-07-31"),
        (17,8,84.0,"2020-07-31"),(18,5,102.5,"2020-07-31"),(18,9,37.5,"2020-07-31"),
        (20,4,95.0,"2020-07-31"),(22,2,78.5,"2020-07-31"),(22,7,69.5,"2020-07-31"),
        (23,3,85.0,"2020-07-31"),(24,3,85.0,"2020-07-31"),(25,9,42.5,"2020-07-31"),
        (25,10,31.99,"2020-07-31"),(26,4,95.0,"2020-07-31"),(27,8,84.0,"2020-07-31"),
        (27,9,41.5,"2020-07-31"),(29,6,124.5,"2020-07-31"),(30,1,70.0,"2020-07-31"),
        (30,2,70.0,"2020-07-31")]
        
df_facturas_mes_ant = spark.createDataFrame(data, columns)
df_facturas_mes_ant.write.mode("overwrite").option("encoding", "UTF-8").saveAsTable('df_facturas_mes_ant')


columns = ['id_cliente','id_oferta','importe','fecha'] 
data = [(1,6,124.5,"2020-08-31"),(1,6,118.60,"2020-08-31"),(2,4,95.0,"2020-08-31"),
        (3,5,102.5,"2020-08-31"),(4,1,70.0,"2020-08-31"),(5,7,80.5,"2020-08-31"),
        (5,9,40.5,"2020-08-31"),(6,8,84.0,"2020-08-31"),(7,4,95.0,"2020-08-31"),
        (8,5,100.5,"2020-08-31"),(9,7,78.50,"2020-08-31"),(9,10,29.99,"2020-08-31"),
        (10,6,124.5,"2020-08-31"),(11,3,83.0,"2020-08-31"),(12,1,70.0,"2020-08-31"),
        (13,4,95.0,"2020-08-31"),(14,9,42.5,"2020-08-31"),(15,2,78.50,"2020-08-31"),
        (15,6,115.0,"2020-08-31"),(17,8,84.0,"2020-08-31"),(18,5,102.5,"2020-08-31"),
        (18,9,39.0,"2020-08-31"),(19,3,85.0,"2020-08-31"),(21,6,124.50,"2020-08-31"),
        (22,2,78.5,"2020-08-31"),(22,7,72.5,"2020-08-31"),(23,3,85.0,"2020-08-31"),
        (25,9,42.5,"2020-08-31"),(25,10,29.70,"2020-08-31"),(26,4,95.0,"2020-08-31"),
        (27,8,84.0,"2020-08-31"),(28,5,102.50,"2020-08-31"),(29,6,121.50,"2020-08-31"),
        (30,1,70.0,"2020-08-31"),(30,2,71.0,"2020-08-31")]
 
df_facturas_mes_actual = spark.createDataFrame(data, columns)
df_facturas_mes_actual.write.mode("overwrite").option("encoding", "UTF-8").saveAsTable('df_facturas_mes_actual')

columns = ['id_cliente','consumo_datos_MB','sms_enviados','minutos_llamadas_movil','minutos_llamadas_fijo','fecha']
data = [(1,664,3,25,0,"2020-08-01"),(1,943,0,12,5,"2020-08-02"),(1,1035,1,46,10,"2020-08-03"),(1,760,3,17,0,"2020-08-04"),
        (1,1409,1,31,4,"2020-08-05"),(1,1627,0,20,0,"2020-08-06"),(1,739,3,21,0,"2020-08-07"),(1,760,0,12,0,"2020-08-08"),
        (1,928,0,0,24,"2020-08-09"),(1,829,2,46,0,"2020-08-10"),(1,1810,3,0,0,"2020-08-11"),(1,760,0,25,0,"2020-08-12"),
        (1,603,0,41,0,"2020-08-13"),(1,732,0,34,102,"2020-08-14"),(1,729,1,0,50,"2020-08-15"),(1,760,1,31,0,"2020-08-16"),
        (1,1934,2,78,0,"2020-08-17"),(1,827,0,29,32,"2020-08-18"),(1,691,0,0,7,"2020-08-19"),(1,760,2,19,0,"2020-08-20"),
        (1,1142,5,14,0,"2020-08-21"),(1,1242,1,40,0,"2020-08-22"),(1,830,0,32,2,"2020-08-23"),(1,760,4,56,17,"2020-08-24"),
        (1,734,0,19,0,"2020-08-25"),(1,1729,0,11,0,"2020-08-26"),(1,819,1,95,18,"2020-08-27"),(1,760,0,60,12,"2020-08-28"),
        (1,302,0,29,0,"2020-08-29"),(1,497,3,14,0,"2020-08-30"),(1,1281,2,21,0,"2020-08-31"),
        (2,321,7,38,13,"2020-08-01"),(2,145,0,8,0,"2020-08-02"),(2,420,1,46,4,"2020-08-03"),(2,492,1,9,0,"2020-08-04"),
        (2,264,8,29,31,"2020-08-05"),(2,172,10,22,0,"2020-08-06"),(2,314,2,74,34,"2020-08-07"),(2,312,2,0,16,"2020-08-08"),
        (2,312,11,32,27,"2020-08-09"),(2,243,2,48,0,"2020-08-10"),(2,423,4,38,12,"2020-08-11"),(2,492,1,10,22,"2020-08-12"),
        (2,492,12,29,29,"2020-08-13"),(2,274,4,60,0,"2020-08-14"),(2,402,0,28,20,"2020-08-15"),(2,471,0,12,30,"2020-08-16"),
        (2,462,1,36,32,"2020-08-17"),(2,294,3,78,42,"2020-08-18"),(2,593,0,29,65,"2020-08-19"),(2,380,12,53,9,"2020-08-20"),
        (2,568,2,42,20,"2020-08-21"),(2,300,2,40,35,"2020-08-22"),(2,600,0,35,29,"2020-08-23"),(2,397,9,37,40,"2020-08-24"),
        (2,623,4,59,42,"2020-08-25"),(2,302,1,34,15,"2020-08-26"),(2,319,1,52,34,"2020-08-27"),(2,901,8,28,83,"2020-08-28"),
        (2,611,0,41,38,"2020-08-29"),(2,319,0,21,19,"2020-08-30"),(2,387,3,19,18,"2020-08-31"),
        (3,123,5,42,14,"2020-08-01"),(3,460,4,24,16,"2020-08-02"),(3,291,3,27,18,"2020-08-03"),(3,149,7,20,0,"2020-08-04"),
        (3,182,6,20,19,"2020-08-05"),(3,245,12,28,21,"2020-08-06"),(3,302,2,31,26,"2020-08-07"),(3,200,8,18,8,"2020-08-08"),
        (3,239,7,40,25,"2020-08-09"),(3,111,9,29,0,"2020-08-10"),(3,191,1,14,29,"2020-08-11"),(3,28,12,4,10,"2020-08-12"),
        (3,201,3,15,32,"2020-08-13"),(3,102,8,31,0,"2020-08-14"),(3,62,10,29,31,"2020-08-15"),(3,82,2,49,42,"2020-08-16"),
        (3,72,1,0,15,"2020-08-17"),(3,94,2,12,18,"2020-08-18"),(3,30,11,20,45,"2020-08-19"),(3,172,1,63,8,"2020-08-20"),
        (3,80,1,12,30,"2020-08-21"),(3,274,7,5,11,"2020-08-22"),(3,219,7,8,15,"2020-08-23"),(3,104,7,6,2,"2020-08-24"),
        (3,180,9,48,45,"2020-08-25"),(3,210,0,10,44,"2020-08-26"),(3,310,2,17,18,"2020-08-27"),(3,182,9,0,1,"2020-08-28"),
        (3,164,0,32,5,"2020-08-29"),(3,289,0,12,33,"2020-08-30"),(3,126,3,23,22,"2020-08-31"),
        (4,523,0,87,0,"2020-08-01"),(4,628,1,56,0,"2020-08-02"),(4,1021,0,15,0,"2020-08-03"),(4,610,1,45,0,"2020-08-04"),
        (4,612,0,65,0,"2020-08-05"),(4,359,0,102,15,"2020-08-06"),(4,832,1,62,0,"2020-08-07"),(4,583,0,30,0,"2020-08-08"),
        (4,490,2,81,20,"2020-08-09"),(4,479,0,81,0,"2020-08-10"),(4,792,2,19,0,"2020-08-11"),(4,1216,0,27,32,"2020-08-12"),
        (4,512,0,32,0,"2020-08-13"),(4,824,4,76,0,"2020-08-14"),(4,682,1,37,18,"2020-08-15"),(4,829,2,47,0,"2020-08-16"),
        (4,921,0,45,0,"2020-08-17"),(4,729,0,42,0,"2020-08-18"),(4,534,2,95,64,"2020-08-19"),(4,967,3,51,82,"2020-08-20"),
        (4,721,3,54,0,"2020-08-21"),(4,218,0,38,17,"2020-08-22"),(4,729,0,85,0,"2020-08-23"),(4,826,1,38,0,"2020-08-24"),
        (4,845,1,34,0,"2020-08-25"),(4,367,2,71,21,"2020-08-26"),(4,502,0,60,0,"2020-08-27"),(4,800,0,25,0,"2020-08-28"),
        (4,629,0,49,0,"2020-08-29"),(4,588,0,50,0,"2020-08-30"),(4,693,1,31,40,"2020-08-31"),
        (5,241,1,125,20,"2020-08-01"),(5,315,0,36,32,"2020-08-02"),(5,301,1,20,80,"2020-08-03"),(5,152,5,38,62,"2020-08-04"),
        (5,289,4,110,45,"2020-08-05"),(5,510,2,74,40,"2020-08-06"),(5,178,2,19,67,"2020-08-07"),(5,241,3,41,59,"2020-08-08"),
        (5,301,6,62,39,"2020-08-09"),(5,86,4,82,47,"2020-08-10"),(5,201,6,75,61,"2020-08-11"),(5,358,8,51,62,"2020-08-12"),
        (5,176,8,45,0,"2020-08-13"),(5,109,5,102,12,"2020-08-14"),(5,798,5,91,45,"2020-08-15"),(5,301,0,43,71,"2020-08-16"),
        (5,198,9,73,70,"2020-08-17"),(5,125,2,115,17,"2020-08-18"),(5,182,4,99,49,"2020-08-19"),(5,222,0,30,80,"2020-08-20"),
        (5,234,3,82,34,"2020-08-21"),(5,201,3,70,20,"2020-08-22"),(5,283,3,130,27,"2020-08-23"),(5,333,2,28,0,"2020-08-24"),
        (5,387,5,90,41,"2020-08-25"),(5,258,5,62,30,"2020-08-26"),(5,251,7,100,36,"2020-08-27"),(5,475,6,79,16,"2020-08-28"),
        (5,312,12,15,80,"2020-08-29"),(5,328,1,50,19,"2020-08-30"),(5,291,11,32,65,"2020-08-31"),
        (6,50,7,10,50,"2020-08-01"),(6,80,6,10,0,"2020-08-02"),(6,65,12,0,40,"2020-08-03"),(6,284,14,0,42,"2020-08-04"),
        (6,20,9,0,46,"2020-08-05"),(6,36,4,0,67,"2020-08-06"),(6,90,9,10,36,"2020-08-07"),(6,201,18,0,83,"2020-08-08"),
        (6,28,13,0,64,"2020-08-09"),(6,150,7,22,46,"2020-08-10"),(6,135,7,0,65,"2020-08-11"),(6,196,22,17,68,"2020-08-12"),
        (6,49,15,0,37,"2020-08-13"),(6,0,0,0,92,"2020-08-14"),(6,122,6,0,56,"2020-08-15"),(6,146,3,0,94,"2020-08-16"),
        (6,102,13,15,48,"2020-08-17"),(6,38,8,0,17,"2020-08-18"),(6,180,11,14,41,"2020-08-19"),(6,159,6,0,26,"2020-08-20"),
        (6,27,16,24,50,"2020-08-21"),(6,156,12,0,75,"2020-08-22"),(6,193,10,20,39,"2020-08-23"),(6,478,4,30,64,"2020-08-24"),
        (6,35,5,0,80,"2020-08-25"),(6,120,15,28,52,"2020-08-26"),(6,201,8,0,54,"2020-08-27"),(6,310,1,28,15,"2020-08-28"),
        (6,40,3,8,35,"2020-08-29"),(6,73,4,16,34,"2020-08-30"),(6,174,7,25,13,"2020-08-31"),
        (7,1456,0,37,0,"2020-08-01"),(7,946,0,24,24,"2020-08-02"),(7,1302,0,72,0,"2020-08-03"),(7,1356,0,13,45,"2020-08-04"),
        (7,1256,1,28,0,"2020-08-05"),(7,985,0,11,5,"2020-08-06"),(7,934,0,40,0,"2020-08-07"),(7,464,1,65,0,"2020-08-08"),
        (7,930,0,0,0,"2020-08-09"),(7,1385,0,30,0,"2020-08-10"),(7,635,0,38,0,"2020-08-11"),(7,588,2,60,0,"2020-08-12"),
        (7,849,2,40,0,"2020-08-13"),(7,1405,3,10,0,"2020-08-14"),(7,911,2,67,24,"2020-08-15"),(7,1495,0,83,0,"2020-08-16"),
        (7,830,0,47,23,"2020-08-17"),(7,1295,0,52,0,"2020-08-18"),(7,844,1,9,0,"2020-08-19"),(7,1246,0,12,4,"2020-08-20"),
        (7,1044,0,28,0,"2020-08-21"),(7,732,1,0,0,"2020-08-22"),(7,1468,4,13,0,"2020-08-23"),(7,967,0,79,0,"2020-08-24"),
        (7,1953,1,17,19,"2020-08-25"),(7,802,0,24,11,"2020-08-26"),(7,1853,1,71,15,"2020-08-27"),(7,1344,0,61,16,"2020-08-28"),
        (7,1067,2,13,0,"2020-08-29"),(7,1740,0,33,57,"2020-08-30"),(7,1122,0,38,12,"2020-08-31"),
        (8,346,5,75,30,"2020-08-01"),(8,502,6,74,40,"2020-08-02"),(8,482,1,12,62,"2020-08-03"),(8,200,10,63,69,"2020-08-04"),
        (8,386,6,83,29,"2020-08-05"),(8,310,3,62,28,"2020-08-06"),(8,500,3,123,0,"2020-08-07"),(8,284,5,71,31,"2020-08-08"),
        (8,305,12,42,19,"2020-08-09"),(8,375,13,80,15,"2020-08-10"),(8,319,5,84,29,"2020-08-11"),(8,249,4,42,53,"2020-08-12"),
        (8,401,10,26,0,"2020-08-13"),(8,281,15,37,76,"2020-08-14"),(8,318,7,86,34,"2020-08-15"),(8,394,8,39,12,"2020-08-16"),
        (8,250,8,56,63,"2020-08-17"),(8,272,4,42,59,"2020-08-18"),(8,492,1,70,46,"2020-08-19"),(8,365,3,51,33,"2020-08-20"),
        (8,284,2,12,25,"2020-08-21"),(8,266,5,50,15,"2020-08-22"),(8,172,1,67,12,"2020-08-23"),(8,402,0,68,8,"2020-08-24"),
        (8,265,4,103,31,"2020-08-25"),(8,388,9,62,43,"2020-08-26"),(8,193,1,48,43,"2020-08-27"),(8,95,6,77,18,"2020-08-28"),
        (8,192,0,93,22,"2020-08-29"),(8,293,12,71,55,"2020-08-30"),(8,174,1,52,36,"2020-08-31"),
        (9,1304,0,13,0,"2020-08-01"),(9,720,0,11,5,"2020-08-02"),(9,1111,1,8,12,"2020-08-03"),(9,1760,1,5,1,"2020-08-04"),
        (9,1502,1,0,3,"2020-08-05"),(9,1455,2,21,0,"2020-08-06"),(9,850,2,7,0,"2020-08-07"),(9,799,2,7,7,"2020-08-08"),
        (9,623,0,5,0,"2020-08-09"),(9,1294,1,5,0,"2020-08-10"),(9,950,0,4,0,"2020-08-11"),(9,923,0,15,0,"2020-08-12"),
        (9,730,0,8,0,"2020-08-13"),(9,823,0,0,0,"2020-08-14"),(9,957,0,0,7,"2020-08-15"),(9,829,0,0,2,"2020-08-16"),
        (9,945,0,0,5,"2020-08-17"),(9,392,0,0,3,"2020-08-18"),(9,1028,0,3,12,"2020-08-19"),(9,729,0,0,0,"2020-08-20"),
        (9,920,4,4,0,"2020-08-21"),(9,720,1,2,9,"2020-08-22"),(9,1932,0,8,27,"2020-08-23"),(9,999,3,0,6,"2020-08-24"),
        (9,869,0,8,0,"2020-08-25"),(9,1830,0,20,15,"2020-08-26"),(9,1234,1,0,0,"2020-08-27"),(9,1885,4,24,13,"2020-08-28"),
        (9,888,2,13,0,"2020-08-29"),(9,929,1,7,6,"2020-08-30"),(9,606,2,37,0,"2020-08-31"),
        (10,482,3,35,20,"2020-08-01"),(10,418,0,32,18,"2020-08-02"),(10,382,3,22,24,"2020-08-03"),(10,212,2,30,16,"2020-08-04"),
        (10,510,7,43,6,"2020-08-05"),(10,399,1,43,25,"2020-08-06"),(10,593,0,23,25,"2020-08-07"),(10,392,2,4,25,"2020-08-08"),
        (10,692,0,13,17,"2020-08-09"),(10,312,0,2,15,"2020-08-10"),(10,492,0,13,27,"2020-08-11"),(10,433,0,32,18,"2020-08-12"),
        (10,582,2,0,29,"2020-08-13"),(10,422,3,31,6,"2020-08-14"),(10,598,1,4,46,"2020-08-15"),(10,510,0,50,12,"2020-08-16"),
        (10,382,5,34,0,"2020-08-17"),(10,628,0,0,21,"2020-08-18"),(10,428,4,22,37,"2020-08-19"),(10,413,1,12,34,"2020-08-20"),
        (10,318,6,6,7,"2020-08-21"),(10,700,2,16,30,"2020-08-22"),(10,1021,5,11,32,"2020-08-23"),(10,284,8,0,28,"2020-08-24"),
        (10,492,2,3,6,"2020-08-25"),(10,238,0,21,16,"2020-08-26"),(10,453,0,0,17,"2020-08-27"),(10,333,10,6,14,"2020-08-28"),
        (10,609,0,14,16,"2020-08-29"),(10,395,5,0,7,"2020-08-30"),(10,530,1,9,0,"2020-08-31"),
        (11,2134,0,8,11,"2020-08-01"),(11,1093,0,18,12,"2020-08-02"),(11,1467,0,15,2,"2020-08-03"),(11,1760,0,4,9,"2020-08-04"),
        (11,1482,0,12,0,"2020-08-05"),(11,1004,0,0,2,"2020-08-06"),(11,2402,1,0,8,"2020-08-07"),(11,838,1,0,0,"2020-08-08"),
        (11,922,0,0,0,"2020-08-09"),(11,983,2,2,3,"2020-08-10"),(11,1803,1,7,10,"2020-08-11"),(11,927,0,12,4,"2020-08-12"),
        (11,1450,1,16,3,"2020-08-13"),(11,889,0,7,9,"2020-08-14"),(11,1234,0,28,0,"2020-08-15"),(11,1583,0,17,0,"2020-08-16"),
        (11,1503,0,0,0,"2020-08-17"),(11,798,1,0,3,"2020-08-18"),(11,1652,0,0,0,"2020-08-19"),(11,1362,0,0,6,"2020-08-20"),
        (11,1793,0,0,0,"2020-08-21"),(11,1928,0,0,0,"2020-08-22"),(11,821,0,7,11,"2020-08-23"),(11,1278,1,0,0,"2020-08-24"),
        (11,1112,0,7,18,"2020-08-25"),(11,1356,0,19,4,"2020-08-26"),(11,629,2,15,0,"2020-08-27"),(11,1029,2,8,13,"2020-08-28"),
        (11,829,0,4,8,"2020-08-29"),(11,1224,3,0,0,"2020-08-30"),(11,492,0,6,8,"2020-08-31"),
        (12,92,5,32,30,"2020-08-01"),(12,201,1,21,17,"2020-08-02"),(12,218,12,8,13,"2020-08-03"),(12,49,2,21,4,"2020-08-04"),
        (12,134,8,16,40,"2020-08-05"),(12,192,8,19,23,"2020-08-06"),(12,167,15,9,6,"2020-08-07"),(12,92,12,24,16,"2020-08-08"),
        (12,27,1,39,21,"2020-08-09"),(12,78,17,27,15,"2020-08-10"),(12,51,8,17,8,"2020-08-11"),(12,106,14,12,13,"2020-08-12"),
        (12,39,5,27,72,"2020-08-13"),(12,90,4,18,31,"2020-08-14"),(12,73,9,10,0,"2020-08-15"),(12,176,12,9,7,"2020-08-16"),
        (12,182,0,17,52,"2020-08-17"),(12,91,8,12,8,"2020-08-18"),(12,82,7,0,6,"2020-08-19"),(12,234,6,0,15,"2020-08-20"),
        (12,76,9,10,29,"2020-08-21"),(12,108,6,18,8,"2020-08-22"),(12,72,9,14,25,"2020-08-23"),(12,188,2,7,8,"2020-08-24"),
        (12,111,13,11,17,"2020-08-25"),(12,115,0,7,9,"2020-08-26"),(12,63,6,30,4,"2020-08-27"),(12,177,0,17,22,"2020-08-28"),
        (12,124,12,20,28,"2020-08-29"),(12,100,3,0,13,"2020-08-30"),(12,94,14,19,13,"2020-08-31"),  
        (13,530,5,15,12,"2020-08-01"),(13,736,4,0,0,"2020-08-02"),(13,649,4,13,22,"2020-08-03"),(13,698,6,0,0,"2020-08-04"),
        (13,721,2,17,23,"2020-08-05"),(13,816,2,18,6,"2020-08-06"),(13,701,3,19,18,"2020-08-07"),(13,726,7,0,17,"2020-08-08"),
        (13,394,3,9,18,"2020-08-09"),(13,793,0,9,2,"2020-08-10"),(13,612,9,0,5,"2020-08-11"),(13,746,2,14,8,"2020-08-12"),
        (13,455,1,0,14,"2020-08-13"),(13,439,1,21,7,"2020-08-14"),(13,682,8,7,9,"2020-08-15"),(13,893,0,19,23,"2020-08-16"),
        (13,801,0,13,0,"2020-08-17"),(13,399,7,2,15,"2020-08-18"),(13,723,0,16,15,"2020-08-19"),(13,487,0,21,22,"2020-08-20"),
        (13,739,6,20,8,"2020-08-21"),(13,465,6,3,5,"2020-08-22"),(13,788,3,7,13,"2020-08-23"),(13,589,5,12,6,"2020-08-24"),
        (13,666,2,13,3,"2020-08-25"),(13,582,0,0,16,"2020-08-26"),(13,625,7,12,12,"2020-08-27"),(13,501,3,4,8,"2020-08-28"),
        (13,615,0,9,14,"2020-08-29"),(13,611,3,4,16,"2020-08-30"),(13,791,4,9,28,"2020-08-31"),
        (14,983,1,34,61,"2020-08-01"),(14,999,1,78,32,"2020-08-02"),(14,1039,0,34,19,"2020-08-03"),(14,772,1,53,31,"2020-08-04"),
        (14,1023,0,29,27,"2020-08-05"),(14,983,0,60,31,"2020-08-06"),(14,1324,0,28,29,"2020-08-07"),(14,861,3,49,30,"2020-08-08"),
        (14,1034,0,38,42,"2020-08-09"),(14,836,0,0,46,"2020-08-10"),(14,927,0,35,44,"2020-08-11"),(14,697,2,26,8,"2020-08-12"),
        (14,802,0,55,12,"2020-08-13"),(14,782,0,13,34,"2020-08-14"),(14,915,1,50,18,"2020-08-15"),(14,810,0,20,17,"2020-08-16"),
        (14,709,2,71,22,"2020-08-17"),(14,888,2,12,19,"2020-08-18"),(14,827,0,38,33,"2020-08-19"),(14,1293,0,9,29,"2020-08-20"),
        (14,1823,0,59,0,"2020-08-21"),(14,1083,0,23,12,"2020-08-22"),(14,1381,1,29,19,"2020-08-23"),(14,1173,1,13,39,"2020-08-24"),
        (14,1432,0,24,47,"2020-08-25"),(14,1063,0,42,19,"2020-08-26"),(14,1402,0,33,59,"2020-08-27"),(14,929,0,13,74,"2020-08-28"),
        (14,1304,0,14,59,"2020-08-29"),(14,1145,3,33,30,"2020-08-30"),(14,1102,0,72,0,"2020-08-31"),
        (15,539,3,13,26,"2020-08-01"),(15,617,0,27,14,"2020-08-02"),(15,729,0,18,10,"2020-08-03"),(15,521,1,0,24,"2020-08-04"),
        (15,491,0,14,22,"2020-08-05"),(15,719,4,7,27,"2020-08-06"),(15,821,0,8,11,"2020-08-07"),(15,594,1,32,7,"2020-08-08"),
        (15,928,4,8,16,"2020-08-09"),(15,830,3,0,16,"2020-08-10"),(15,902,3,0,6,"2020-08-11"),(15,492,4,22,12,"2020-08-12"),
        (15,619,6,9,14,"2020-08-13"),(15,715,2,25,2,"2020-08-14"),(15,762,5,12,1,"2020-08-15"),(15,378,7,3,24,"2020-08-16"),
        (15,729,8,17,0,"2020-08-17"),(15,785,6,4,8,"2020-08-18"),(15,681,12,17,27,"2020-08-19"),(15,402,5,8,2,"2020-08-20"),
        (15,800,2,0,6,"2020-08-21"),(15,516,8,0,0,"2020-08-22"),(15,535,3,9,5,"2020-08-23"),(15,501,4,7,1,"2020-08-24"),
        (15,910,1,2,6,"2020-08-25"),(15,684,9,21,9,"2020-08-26"),(15,587,2,18,12,"2020-08-27"),(15,610,2,14,18,"2020-08-28"),
        (15,527,5,16,0,"2020-08-29"),(15,901,2,13,15,"2020-08-30"),(15,534,0,6,14,"2020-08-31"),
        (17,1648,0,3,0,"2020-08-01"),(17,1849,0,6,11,"2020-08-02"),(17,1453,0,12,10,"2020-08-03"),(17,921,0,13,5,"2020-08-04"),
        (17,1623,0,0,0,"2020-08-05"),(17,1632,0,0,0,"2020-08-06"),(17,1829,0,2,9,"2020-08-07"),(17,1834,1,0,5,"2020-08-08"),
        (17,2341,0,0,7,"2020-08-09"),(17,2483,2,0,8,"2020-08-10"),(17,1712,1,2,3,"2020-08-11"),(17,1749,0,12,9,"2020-08-12"),
        (17,1232,0,0,0,"2020-08-13"),(17,2013,0,2,0,"2020-08-14"),(17,1144,1,4,7,"2020-08-15"),(17,1334,2,21,0,"2020-08-16"),
        (17,1552,0,0,0,"2020-08-17"),(17,1934,0,3,5,"2020-08-18"),(17,1536,0,11,2,"2020-08-19"),(17,1346,0,3,1,"2020-08-20"),
        (17,920,1,8,6,"2020-08-21"),(17,1235,1,10,2,"2020-08-22"),(17,2184,1,13,8,"2020-08-23"),(17,1765,3,6,8,"2020-08-24"),
        (17,1928,0,5,4,"2020-08-25"),(17,1321,0,5,1,"2020-08-26"),(17,2562,0,0,18,"2020-08-27"),(17,1113,0,11,11,"2020-08-28"),
        (17,1057,0,3,0,"2020-08-29"),(17,1022,0,0,7,"2020-08-30"),(17,1240,0,0,0,"2020-08-31"),
        (18,782,0,46,54,"2020-08-01"),(18,492,6,40,31,"2020-08-02"),(18,362,1,49,28,"2020-08-03"),(18,593,7,12,34,"2020-08-04"),
        (18,892,2,24,62,"2020-08-05"),(18,584,3,4,52,"2020-08-06"),(18,392,0,21,35,"2020-08-07"),(18,793,1,29,29,"2020-08-08"),
        (18,1639,4,32,23,"2020-08-09"),(18,493,0,62,14,"2020-08-10"),(18,418,4,44,49,"2020-08-11"),(18,632,0,85,24,"2020-08-12"),
        (18,622,1,18,27,"2020-08-13"),(18,302,4,21,19,"2020-08-14"),(18,472,2,20,38,"2020-08-15"),(18,535,5,37,19,"2020-08-16"),
        (18,522,5,9,49,"2020-08-17"),(18,592,7,42,35,"2020-08-18"),(18,520,3,19,37,"2020-08-19"),(18,589,5,20,29,"2020-08-20"),
        (18,482,6,19,18,"2020-08-21"),(18,857,4,19,72,"2020-08-22"),(18,539,8,4,13,"2020-08-23"),(18,470,1,44,31,"2020-08-24"),
        (18,527,2,49,38,"2020-08-25"),(18,496,0,23,32,"2020-08-26"),(18,611,6,39,19,"2020-08-27"),(18,593,2,54,40,"2020-08-28"),
        (18,812,0,75,21,"2020-08-29"),(18,523,2,29,42,"2020-08-30"),(18,389,0,82,14,"2020-08-31"),
        (19,1345,1,18,21,"2020-08-01"),(19,1520,3,20,18,"2020-08-02"),(19,1037,4,19,12,"2020-08-03"),(19,1628,0,18,11,"2020-08-04"),
        (19,1129,0,14,7,"2020-08-05"),(19,1045,0,19,19,"2020-08-06"),(19,1122,3,14,15,"2020-08-07"),(19,1072,1,23,14,"2020-08-08"),
        (19,1249,2,19,17,"2020-08-09"),(19,1294,4,14,16,"2020-08-10"),(19,972,0,20,13,"2020-08-11"),(19,882,0,19,8,"2020-08-12"),
        (19,938,2,20,8,"2020-08-13"),(19,1183,0,9,8,"2020-08-14"),(19,927,2,28,19,"2020-08-15"),(19,926,1,10,7,"2020-08-16"),
        (19,910,0,11,16,"2020-08-17"),(19,1009,3,15,20,"2020-08-18"),(19,899,0,7,9,"2020-08-19"),(19,935,4,12,19,"2020-08-20"),
        (19,888,0,12,22,"2020-08-21"),(19,1212,2,11,18,"2020-08-22"),(19,1322,3,11,15,"2020-08-23"),(19,1088,2,6,13,"2020-08-24"),
        (19,1420,4,21,29,"2020-08-25"),(19,988,0,17,9,"2020-08-26"),(19,1129,0,8,10,"2020-08-27"),(19,1333,0,17,16,"2020-08-28"),
        (19,1333,1,27,19,"2020-08-29"),(19,892,1,10,4,"2020-08-30"),(19,1341,2,13,9,"2020-08-31"),
        (21,1483,0,53,34,"2020-08-01"),(21,1938,0,34,42,"2020-08-02"),(21,1305,0,78,22,"2020-08-03"),(21,1324,0,25,39,"2020-08-04"),
        (21,1837,0,32,28,"2020-08-05"),(21,2183,0,21,38,"2020-08-06"),(21,1735,1,26,43,"2020-08-07"),(21,1253,3,41,19,"2020-08-08"),
        (21,983,1,35,20,"2020-08-09"),(21,1634,3,17,29,"2020-08-10"),(21,1538,0,33,19,"2020-08-11"),(21,1653,0,55,67,"2020-08-12"),
        (21,1038,0,21,17,"2020-08-13"),(21,826,0,20,17,"2020-08-14"),(21,1492,1,82,34,"2020-08-15"),(21,1403,0,31,56,"2020-08-16"),
        (21,1392,0,27,19,"2020-08-17"),(21,1542,0,17,34,"2020-08-18"),(21,937,0,77,40,"2020-08-19"),(21,1839,0,20,42,"2020-08-20"),
        (21,1837,0,31,30,"2020-08-21"),(21,1639,0,32,46,"2020-08-22"),(21,827,1,23,37,"2020-08-23"),(21,1432,1,45,39,"2020-08-24"),
        (21,803,0,14,52,"2020-08-25"),(21,1329,0,82,52,"2020-08-26"),(21,1748,0,81,12,"2020-08-27"),(21,1522,1,50,50,"2020-08-28"),
        (21,1432,2,39,42,"2020-08-29"),(21,1238,1,68,51,"2020-08-30"),(21,2242,0,54,32,"2020-08-31"),
        (22,2403,0,52,43,"2020-08-01"),(22,2912,0,61,30,"2020-08-02"),(22,1098,1,83,21,"2020-08-03"),(22,2183,2,61,39,"2020-08-04"),
        (22,2421,0,19,37,"2020-08-05"),(22,2182,1,18,29,"2020-08-06"),(22,1128,0,66,55,"2020-08-07"),(22,2382,0,53,48,"2020-08-08"),
        (22,2018,0,22,39,"2020-08-09"),(22,1592,0,28,27,"2020-08-10"),(22,829,0,47,30,"2020-08-11"),(22,2110,0,20,20,"2020-08-12"),
        (22,1732,0,49,28,"2020-08-13"),(22,1037,0,68,21,"2020-08-14"),(22,1638,0,29,17,"2020-08-15"),(22,1044,0,16,44,"2020-08-16"),
        (22,1731,1,8,22,"2020-08-17"),(22,1111,0,72,19,"2020-08-18"),(22,1543,0,35,39,"2020-08-19"),(22,937,0,59,21,"2020-08-20"),
        (22,1372,0,3,53,"2020-08-21"),(22,1762,0,18,35,"2020-08-22"),(22,1472,0,13,28,"2020-08-23"),(22,2493,0,20,46,"2020-08-24"),
        (22,1138,0,13,42,"2020-08-25"),(22,1662,0,9,13,"2020-08-26"),(22,1600,0,95,8,"2020-08-27"),(22,891,0,39,53,"2020-08-28"),
        (22,1240,0,72,31,"2020-08-29"),(22,1144,0,23,38,"2020-08-30"),(22,1593,1,52,29,"2020-08-31"),
        (23,222,2,50,55,"2020-08-01"),(23,62,0,60,32,"2020-08-02"),(23,26,0,30,22,"2020-08-03"),(23,29,1,7,67,"2020-08-04"),
        (23,169,1,62,42,"2020-08-05"),(23,173,0,47,51,"2020-08-06"),(23,135,0,18,48,"2020-08-07"),(23,99,0,50,15,"2020-08-08"),
        (23,82,0,38,46,"2020-08-09"),(23,200,0,23,30,"2020-08-10"),(23,147,0,21,49,"2020-08-11"),(23,178,0,42,21,"2020-08-12"),
        (23,183,0,30,51,"2020-08-13"),(23,144,0,28,36,"2020-08-14"),(23,168,0,30,30,"2020-08-15"),(23,299,2,30,8,"2020-08-16"),
        (23,283,0,41,29,"2020-08-17"),(23,152,2,19,45,"2020-08-18"),(23,291,0,34,31,"2020-08-19"),(23,219,1,18,19,"2020-08-20"),
        (23,212,0,39,44,"2020-08-21"),(23,169,0,29,39,"2020-08-22"),(23,53,0,29,34,"2020-08-23"),(23,178,0,40,49,"2020-08-24"),
        (23,192,1,50,28,"2020-08-25"),(23,98,0,25,45,"2020-08-26"),(23,22,1,32,85,"2020-08-27"),(23,155,0,33,51,"2020-08-28"),
        (23,73,0,40,46,"2020-08-29"),(23,54,1,14,25,"2020-08-30"),(23,35,3,12,90,"2020-08-31"),
        (25,1839,4,42,19,"2020-08-01"),(25,1555,0,60,6,"2020-08-02"),(25,1412,0,21,7,"2020-08-03"),(25,1242,5,29,14,"2020-08-04"),
        (25,1537,2,32,17,"2020-08-05"),(25,1492,1,32,0,"2020-08-06"),(25,1500,1,27,29,"2020-08-07"),(25,1039,2,37,28,"2020-08-08"),
        (25,1392,0,59,8,"2020-08-09"),(25,1637,0,43,12,"2020-08-10"),(25,902,1,22,49,"2020-08-11"),(25,1183,0,81,8,"2020-08-12"),
        (25,892,3,24,13,"2020-08-13"),(25,1228,3,50,32,"2020-08-14"),(25,1182,4,38,7,"2020-08-15"),(25,1340,0,70,21,"2020-08-16"),
        (25,989,0,9,17,"2020-08-17"),(25,1447,0,72,12,"2020-08-18"),(25,1632,0,83,11,"2020-08-19"),(25,1483,3,63,18,"2020-08-20"),
        (25,1892,4,47,20,"2020-08-21"),(25,963,0,52,27,"2020-08-22"),(25,1701,0,28,17,"2020-08-23"),(25,1204,4,57,19,"2020-08-24"),
        (25,792,1,56,19,"2020-08-25"),(25,1284,0,43,12,"2020-08-26"),(25,1132,5,32,19,"2020-08-27"),(25,1874,1,48,2,"2020-08-28"),
        (25,1638,0,72,11,"2020-08-29"),(25,1195,4,50,22,"2020-08-30"),(25,1233,2,58,4,"2020-08-31"),
        (26,412,5,59,42,"2020-08-01"),(26,298,5,77,45,"2020-08-02"),(26,429,7,34,47,"2020-08-03"),(26,404,8,44,60,"2020-08-04"),
        (26,383,13,38,30,"2020-08-05"),(26,288,7,61,15,"2020-08-06"),(26,502,4,17,50,"2020-08-07"),(26,593,6,29,36,"2020-08-08"),
        (26,492,9,28,24,"2020-08-09"),(26,232,13,21,41,"2020-08-10"),(26,489,3,20,29,"2020-08-11"),(26,605,4,39,52,"2020-08-12"),
        (26,502,2,35,41,"2020-08-13"),(26,399,15,23,33,"2020-08-14"),(26,400,3,40,33,"2020-08-15"),(26,472,13,35,49,"2020-08-16"),
        (26,664,8,18,33,"2020-08-17"),(26,477,6,41,38,"2020-08-18"),(26,302,7,67,28,"2020-08-19"),(26,533,2,58,30,"2020-08-20"),
        (26,544,11,55,25,"2020-08-21"),(26,425,3,57,29,"2020-08-22"),(26,239,14,50,33,"2020-08-23"),(26,421,6,62,43,"2020-08-24"),
        (26,372,13,39,59,"2020-08-25"),(26,362,1,14,40,"2020-08-26"),(26,277,3,60,48,"2020-08-27"),(26,388,10,50,50,"2020-08-28"),
        (26,301,8,78,30,"2020-08-29"),(26,311,9,92,3,"2020-08-30"),(26,399,2,67,21,"2020-08-31"),
        (27,183,5,15,37,"2020-08-01"),(27,283,6,3,29,"2020-08-02"),(27,156,9,33,25,"2020-08-03"),(27,253,14,8,39,"2020-08-04"),
        (27,200,7,22,28,"2020-08-05"),(27,109,8,16,21,"2020-08-06"),(27,161,7,18,48,"2020-08-07"),(27,200,5,12,62,"2020-08-08"),
        (27,126,4,13,31,"2020-08-09"),(27,193,0,7,36,"2020-08-10"),(27,98,5,16,53,"2020-08-11"),(27,121,3,17,30,"2020-08-12"),
        (27,255,9,28,20,"2020-08-13"),(27,244,9,37,24,"2020-08-14"),(27,188,11,21,37,"2020-08-15"),(27,249,6,24,24,"2020-08-16"),
        (27,242,1,31,23,"2020-08-17"),(27,237,15,15,57,"2020-08-18"),(27,264,6,7,54,"2020-08-19"),(27,255,1,41,19,"2020-08-20"),
        (27,251,13,7,44,"2020-08-21"),(27,281,2,30,34,"2020-08-22"),(27,338,3,23,43,"2020-08-23"),(27,201,13,8,57,"2020-08-24"),
        (27,277,11,13,38,"2020-08-25"),(27,299,12,28,19,"2020-08-26"),(27,139,1,22,47,"2020-08-27"),(27,267,10,16,40,"2020-08-28"),
        (27,178,8,19,27,"2020-08-29"),(27,177,17,9,45,"2020-08-30"),(27,87,12,11,18,"2020-08-31"),
        (28,1124,14,5,12,"2020-08-01"),(28,1044,7,7,7,"2020-08-02"),(28,755,13,6,6,"2020-08-03"),(28,1533,18,7,2,"2020-08-04"),
        (28,679,18,8,4,"2020-08-05"),(28,677,11,1,8,"2020-08-06"),(28,632,16,7,0,"2020-08-07"),(28,1034,7,3,3,"2020-08-08"),
        (28,575,2,14,4,"2020-08-09"),(28,732,15,25,0,"2020-08-10"),(28,687,2,3,15,"2020-08-11"),(28,543,9,11,16,"2020-08-12"),
        (28,533,7,4,9,"2020-08-13"),(28,789,4,19,17,"2020-08-14"),(28,555,1,14,9,"2020-08-15"),(28,566,12,13,27,"2020-08-16"),
        (28,423,14,3,5,"2020-08-17"),(28,643,9,7,2,"2020-08-18"),(28,502,7,5,5,"2020-08-19"),(28,624,13,1,17,"2020-08-20"),
        (28,1463,5,0,11,"2020-08-21"),(28,611,12,8,11,"2020-08-22"),(28,487,14,3,16,"2020-08-23"),(28,620,8,22,0,"2020-08-24"),
        (28,699,11,14,8,"2020-08-25"),(28,586,10,17,0,"2020-08-26"),(28,679,9,0,4,"2020-08-27"),(28,1111,5,9,6,"2020-08-28"),
        (28,581,8,21,10,"2020-08-29"),(28,581,6,4,13,"2020-08-30"),(28,700,6,7,13,"2020-08-31"),
        (29,1524,0,56,25,"2020-08-01"),(29,987,0,42,39,"2020-08-02"),(29,1439,1,34,38,"2020-08-03"),(29,1188,0,41,37,"2020-08-04"),
        (29,1730,0,48,39,"2020-08-05"),(29,1771,0,49,43,"2020-08-06"),(29,1378,0,41,29,"2020-08-07"),(29,1263,0,33,59,"2020-08-08"),
        (29,1930,1,27,57,"2020-08-09"),(29,1849,1,38,36,"2020-08-10"),(29,1598,0,39,37,"2020-08-11"),(29,1730,0,21,68,"2020-08-12"),
        (29,1847,0,64,19,"2020-08-13"),(29,1667,0,30,68,"2020-08-14"),(29,1702,0,68,31,"2020-08-15"),(29,2740,0,28,46,"2020-08-16"),
        (29,1222,0,30,34,"2020-08-17"),(29,1493,4,27,59,"2020-08-18"),(29,1832,2,84,18,"2020-08-19"),(29,2489,0,34,32,"2020-08-20"),
        (29,1352,2,74,40,"2020-08-21"),(29,1339,0,18,22,"2020-08-22"),(29,1440,0,36,36,"2020-08-23"),(29,2009,2,50,56,"2020-08-24"),
        (29,1667,0,55,36,"2020-08-25"),(29,1028,0,37,65,"2020-08-26"),(29,927,0,25,39,"2020-08-27"),(29,2021,0,33,13,"2020-08-28"),
        (29,1599,0,61,38,"2020-08-29"),(29,1088,0,70,39,"2020-08-30"),(29,1073,1,47,27,"2020-08-31"),
        (30,329,2,20,45,"2020-08-01"),(30,222,8,10,47,"2020-08-02"),(30,173,12,4,41,"2020-08-03"),(30,177,13,7,52,"2020-08-04"),
        (30,710,6,10,42,"2020-08-05"),(30,334,2,2,37,"2020-08-06"),(30,123,16,8,39,"2020-08-07"),(30,189,15,8,46,"2020-08-08"),
        (30,400,5,7,29,"2020-08-09"),(30,354,6,20,78,"2020-08-10"),(30,394,9,6,79,"2020-08-11"),(30,207,9,11,83,"2020-08-12"),
        (30,329,0,4,47,"2020-08-13"),(30,378,6,4,44,"2020-08-14"),(30,338,14,7,39,"2020-08-15"),(30,284,2,6,93,"2020-08-16"),
        (30,284,0,6,36,"2020-08-17"),(30,312,13,1,39,"2020-08-18"),(30,267,17,6,29,"2020-08-19"),(30,351,8,15,43,"2020-08-20"),
        (30,244,4,0,67,"2020-08-21"),(30,200,4,14,29,"2020-08-22"),(30,313,11,12,58,"2020-08-23"),(30,273,14,14,55,"2020-08-24"),
        (30,285,12,11,39,"2020-08-25"),(30,173,5,9,55,"2020-08-26"),(30,461,10,13,64,"2020-08-27"),(30,290,17,29,61,"2020-08-28"),
        (30,197,7,8,51,"2020-08-29"),(30,183,15,4,64,"2020-08-30"),(30,245,16,50,43,"2020-08-31")]
 
df_consumos_diarios = spark.createDataFrame(data, columns)
df_consumos_diarios.write.mode("overwrite").option("encoding", "UTF-8").saveAsTable('df_consumos_diarios')

# COMMAND ----------

# MAGIC %md **Then, we import the necessary libraries:**

# COMMAND ----------

from pyspark.sql.functions import *
from pyspark.sql.types import *
from pyspark.sql.window import Window

# COMMAND ----------

# MAGIC %md **1. Display on the screen the TOTAL number of customers who had more than one contract with the company in the previous month.**

# COMMAND ----------

df_facturas_mes_ant = spark.read.table("df_facturas_mes_ant");
df_clientes = spark.read.table("df_clientes");
df_num_contr_por_cli = df_facturas_mes_ant.groupBy("id_cliente").agg(count("*").alias('num_contratos')).filter(col("num_contratos") > 1)
df_nombre_clientes = df_num_contr_por_cli.join(df_clientes, "id_cliente").select("nombre")
display(df_nombre_clientes)

# COMMAND ----------

# MAGIC %md **2. Generate a new dataframe of invoices for the current month that assigns a 7% discount to all contracts of customers who already existed in the previous month (contracts of new customers will remain with the same amount). Keep the "amount" column and create a new column "discounted_amount" with the new amount, rounded to 2 decimals. Also, display the result sorted by the fields id_cliente ascending, amount descending.**

# COMMAND ----------

df_facturas_mes_actual = spark.read.table("df_facturas_mes_actual");
df_facturas_mes_ant = spark.read.table("df_facturas_mes_ant");
# Primero, obtengo un DF exactamente igual que 'df_facturas_mes_actual' pero con una columna extra 'flag_match' que tendrá dos posibles valores:
# - '1' si el contrato de ese cliente en ese registro ya existía el mes pasado.
# - 'null' si el contrato de ese cliente en ese registro es nuevo de este mes.
df_facturas_dos_meses = df_facturas_mes_actual.join(df_facturas_mes_ant.withColumn("flag_match", lit(1)).select("id_cliente", "id_oferta", "importe", "flag_match"), ["id_cliente", "id_oferta", "importe"], "left")
# Finalmente, al DF anterior le creo una nueva columna 'importe_dto' que contenga un 7% del valor de la columna 'importe' si la columna 'flag_match' es '1'. Si es 'null', le doy el mismo valor que el de la columna 'importe':
df_facturas_dos_meses = df_facturas_dos_meses.withColumn("importe_dto", when(col("flag_match") == 1, (col("importe") * 0.93).cast(DecimalType(17,2))).otherwise(col("importe"))).select("id_cliente", "id_oferta", "importe", "importe_dto","fecha").orderBy(asc("id_cliente"), desc("importe"));
display(df_facturas_dos_meses);

# COMMAND ----------

# MAGIC %md The 'discounted_amount' column shows the final amount for each customer, regardless of whether a discount is applied or not.
# MAGIC

# COMMAND ----------

# MAGIC %md **3. Due to network saturation issues caused by increased data usage during the COVID-19 lockdown, it is decided to limit data usage this month by raising the tariff of all offers that include "unlimited data" by 15%. Obtain a DataFrame with the same columns as the DataFrame of invoices for the current month, plus the "discounted_amount" column.**

# COMMAND ----------

df_ofertas = spark.read.table("df_ofertas");
df_facturas_mes_actual = spark.read.table("df_facturas_mes_actual");
# Primero, filtro el DF 'df_ofertas' para seleccionar aquellos cuyo campo 'descripcion' contenga la cadena 'datos ilimitados':
df_ofertas_filter = df_ofertas.filter(col("descripcion").contains("datos ilimitados"))
# Segundo, obtengo un DF exactamente igual que 'df_facturas_dos_meses' (obtenido en el ejercicio anterior) pero con una columna extra 'flag_match' que tendrá dos posibles valores:
# - '1' si el campo 'descripcion' del contrato de ese cliente contiene el string 'datos ilimitados'.
# - 'null' si el campo 'descripcion' del contrato de ese cliente NO contiene el string 'datos ilimitados'.
df_fact_mes_act_lim = df_facturas_dos_meses.join(df_ofertas_filter.withColumn("match_flag", lit(1)).select("id_oferta", "match_flag"), ["id_oferta"], "left")
# Finalmente, aplico un 15% de aumento a los valores de la columna 'importe_dto' si la columna 'flag_match' es '1'. Si es 'null', no aplico ningun cambio:
df_fact_mes_act_lim = df_fact_mes_act_lim.withColumn("importe_dto", when(col("match_flag") == 1, (col("importe_dto")*1.15).cast(DecimalType(17,2))).otherwise(col("importe_dto"))) \
    .withColumn("importe", when(col("match_flag") == 1, (col("importe")*1.15).cast(DecimalType(17,2))).otherwise(col("importe"))) \
    .select("id_cliente", "id_oferta", "importe", "importe_dto", "fecha").orderBy("id_cliente");
display(df_fact_mes_act_lim)

# COMMAND ----------

# MAGIC %md **4. Create a new variable "age_group" that groups customers, both from the current month and the previous month, into 4 ranges according to their age, assigning values from 1 - 4 according to the range they belong to (18-25 (1), 26-40 (2), 41-65 (3), >65 (4)). Obtain a summary table that extracts for each of the 4 identified groups the AVERAGE of data consumption, sent SMS, mobile minutes, landline minutes, with all fields rounded to 2 decimals, and sort the DataFrame by age_group ascending. Extract conclusions.**

# COMMAND ----------

df_clientes = spark.read.table("df_clientes");
df_consumos_diarios = spark.read.table("df_consumos_diarios");
# Creo el DF 'df_clientes_agr' que tiene a los clientes agrupados por 'grupo_edad':
df_clientes_agr = df_clientes.withColumn("grupo_edad", when(col("edad") < 26, lit(1))
                                         .when(col("edad").between(26,40),lit(2))
                                         .when(col("edad").between(41,65),lit(3))
                                         .otherwise(lit(4))).select("id_cliente", "nombre", "grupo_edad")
# Calculo la media de los consumos diarios:
df_cons_diar_agr = df_consumos_diarios.join(df_clientes_agr, ["id_cliente"]).select("grupo_edad", "consumo_datos_MB", "sms_enviados", "minutos_llamadas_movil", "minutos_llamadas_fijo").groupBy("grupo_edad").agg(
    avg("consumo_datos_MB").cast(DecimalType(17,2)).alias("media consumo de datos"),
    avg("sms_enviados").cast(DecimalType(17,2)).alias("media SMS enviados"),
    avg("minutos_llamadas_movil").cast(DecimalType(17,2)).alias("media minutos movil"),
    avg("minutos_llamadas_fijo").cast(DecimalType(17,2)).alias("media llamadas fijos")).orderBy("grupo_edad");
display(df_cons_diar_agr)

# COMMAND ----------

# MAGIC %md
# MAGIC In summary, older individuals tend to prefer more traditional services such as sending SMS and making calls to landline phones, possibly due to their familiarity with these technologies. In contrast, younger people actively adopt newer technologies like mobile data usage, thanks to their adaptability and convenience.
# MAGIC
# MAGIC The lower usage of mobile data by the older age group is likely due to their preference for close and personal interaction involved in voice-to-voice communication rather than text. Additionally, this could be related to their reluctance towards using social media, mobile apps, etc., perhaps because in some cases, they find it challenging to understand how these technologies work.
# MAGIC
# MAGIC Regarding the use of calls to mobile phones, both the youngest and oldest age groups make fewer calls. This can be explained, on one hand, by younger individuals compensating for those few calls with mobile data usage (they don't call because they communicate through text) and could also be explained by the fact that newer generations are increasingly distant from each other and spend a lot of time using unproductive mobile apps and social media instead of having contact with people around them. On the other hand, the low usage of mobile call minutes by the older age group is explained by their preference for landline calls, as they are more accustomed to this practice.

# COMMAND ----------

# MAGIC %md 
# MAGIC **5. A study by gender is wanted to analyze whether women or men consume more data during the weekend and make more calls from their mobile phones. To do this, without the help of a calendar, it will be necessary to extract the day of the week corresponding to each date in the month of August to determine which are weekends (considered as Friday, Saturday, and Sunday).**
# MAGIC
# MAGIC **The resulting DataFrame (DF) should have 2 records with the columns: gender, total_weekend_mobile_minutes, total_weekend_mobile_data.
# MAGIC Draw conclusions after presenting the resulting DF.**

# COMMAND ----------

df_consumos_diarios = spark.read.table("df_consumos_diarios")
# Creo el DF 'df_consumos_diarios_aux', que es identico al DF 'df_consumos_diarios' pero añadiendo la columna 'sexo'
df_consumos_diarios_aux = df_consumos_diarios.join(df_clientes.select("sexo", "id_cliente"), ["id_cliente"]) 

# Al DF 'df_consumos_diarios_aux', le añado la columna 'dia', que contiene el dia de la semana (1 lunes, ..., 7 domingo). Filtro el DF por los dias 5, 6 i 7.
df_consumos_diarios_aux = df_consumos_diarios_aux.withColumn("dia", when(dayofweek(col("fecha")) - 1 == 0, 7).otherwise(dayofweek(col("fecha")) - 1)).select("sexo", "consumo_datos_MB", "dia", "fecha", "minutos_llamadas_movil").filter(col("dia").isin([5, 6, 7]))

# Agrupo el DF por 'sexo' i calculo el total de consumo de datos i minuto de llamadas a movil:
df_consumos_diarios_aux = df_consumos_diarios_aux.groupBy("sexo").agg(sum("consumo_datos_MB").alias("total_datos_moviles_finde"), sum("minutos_llamadas_movil").alias("total_mins_movil_finde")).select("sexo", "total_datos_moviles_finde","total_mins_movil_finde")
display(df_consumos_diarios_aux)

# COMMAND ----------

# MAGIC %md
# MAGIC As can be observed, both women and men use mobile data similarly during the weekend. However, it stands out that, on average, women dedicate twice as much time as men to make phone calls. This disparity could suggest that women tend to be more open or have a greater need to express themselves and share their feelings through verbal communication, while men tend to be more reserved in this aspect.

# COMMAND ----------

# MAGIC %md **Obtain a DataFrame containing 4 records, which will be the customer from each age group who has consumed the most mobile data during the first 15 days of August (day 15 included in the calculation). The DataFrame should contain the columns: name, age, age_group, total_mobile_data_15, max_sms_sent_15** </br> (max_sms_sent_15 contains the maximum number of SMS sent in a day by the customer with the highest mobile data consumption from each age group during those first 15 days of the month). </br>
# MAGIC **Draw conclusions regarding data consumed and SMS sent for each age group.**

# COMMAND ----------

df_consumos_diarios = spark.read.table("df_consumos_diarios")
df_clientes = spark.read.table("df_clientes")
window_grupo_edad = Window.partitionBy("grupo_edad")
# Filtro el DF 'df_consumos_diarios' con los 15 primeros dias del mes, solo con las columnas "id_cliente", "consumo_datos_MB", "sms_enviados".
df_consumos_diarios_aux = df_consumos_diarios.select("id_cliente", "consumo_datos_MB", "sms_enviados").filter(col("fecha").substr(9,2) <= 15)
# Hago join con el DF 'df_clientes' para obtener el nombre y la edad del cliente:
df_consumos_diarios_aux = df_consumos_diarios_aux.join(df_clientes.select("id_cliente", "edad", "nombre"), "id_cliente")
# Agrupo el DF anterior por 'id_cliente' y calculo el total de consumo de datos y el maximo número de sms enviados en un día:
df_consumos_diarios_aux = df_consumos_diarios_aux.groupBy("id_cliente").agg(sum("consumo_datos_MB").alias("datos_moviles_total_15"), max("nombre").alias("nombre"), max("sms_enviados").alias("max_sms_enviados_15"), max("edad").alias("edad")).orderBy("id_cliente")
# Agrupo el DF anterior por 'grupo_edad':
df_consumos_diarios_aux = df_consumos_diarios_aux.withColumn("grupo_edad", when(col("edad") < 26, lit(1))
                                         .when(col("edad").between(26,40),lit(2))
                                         .when(col("edad").between(41,65),lit(3))
                                         .otherwise(lit(4)))
df_consumos_diarios_aux = df_consumos_diarios_aux.withColumn("datos_moviles_max", max("datos_moviles_total_15").
                                                                        over(window_grupo_edad)).filter(col("datos_moviles_total_15") == col("datos_moviles_max")).select("nombre", "edad", "grupo_edad", "datos_moviles_total_15", "max_sms_enviados_15").orderBy("grupo_edad")

display(df_consumos_diarios_aux)

# COMMAND ----------

# MAGIC %md
# MAGIC We can observe that younger individuals tend to use more mobile data, while older age groups seem to prefer using SMS.

# COMMAND ----------

# MAGIC %md **7. We are interested in finding out the call minutes of customers who are new this month to conduct a study on the impact they would have in case of a peak in call volume on the network. Obtain a DataFrame containing only the new customers for this month with 4 columns: new_customer_name, age, total_current_month_amount, total_minutes.** </br>
# MAGIC The resulting DataFrame will be sorted by the "total_minutes" column, which contains the total minutes of fixed and mobile calls during this month for each customer, sorting them so that the first new customer appearing has made the least amount of minutes of calls in the month of August.
# MAGIC NOTES: If there are only 2 new customers, the resulting DataFrame will have only 2 records.
# MAGIC Keep in mind that when performing a join, the joining key must be unique in the right table, or else the resulting records will multiply uncontrollably.
# MAGIC Also, consider that if a new customer has 2 contracted offers, the total_current_month_amount column should contain the sum of the amounts of both offers.

# COMMAND ----------

df_facturas_mes_ant = spark.read.table("df_facturas_mes_ant")
df_facturas_mes_actual = spark.read.table("df_facturas_mes_actual")
df_consumos_diarios = spark.read.table("df_consumos_diarios")
df_clientes = spark.read.table("df_clientes")

# Obtengo un DF igual que 'df_facturas_mes_actual' pero solo con los clientes que son nuevos: 
df_facturas_mes_actual_nuev = df_facturas_mes_actual.join(df_facturas_mes_ant, ["id_cliente"], "left_anti")

# Al DF anterior, le añado la columna del nombre y de la edad del cliente: 
df_facturas_mes_actual_nuev = df_facturas_mes_actual_nuev.join(df_clientes.select("id_cliente", "nombre", "edad"), "id_cliente")

# Al DF anterior, le elimino la columna 'id_oferta' y a la columna 'importe' obtengo la suma (para los clientes con dos ofertas contratadas:
df_facturas_mes_actual_nuev = df_facturas_mes_actual_nuev.groupBy("id_cliente").agg(sum("importe").alias("importe"), max("fecha").alias("fecha"), max("nombre").alias("nombre"), max("edad").alias("edad"))

# Al DF anterior, le añado la información de consumos diarios: 
df_facturas_mes_actual_nuev = df_facturas_mes_actual_nuev.join(df_consumos_diarios, "id_cliente")

# Agrupo el DF anterior por 'id_cliente' y obtengo el total de llamadas que hace cada uno de los clientes nuevos: 
df_facturas_mes_actual_nuev = df_facturas_mes_actual_nuev.groupBy("id_cliente") \
    .agg((sum("minutos_llamadas_movil") + sum("minutos_llamadas_fijo")).alias("total_minutos"),
         max("importe").alias("importe_total_mes_actual"),
         max("nombre").alias("nombre_cliente_nuevo"),
         max("edad").alias("edad")) \
    .orderBy(asc("total_minutos")) \
    .select("nombre_cliente_nuevo", "importe_total_mes_actual", "edad", "total_minutos")
display(df_facturas_mes_actual_nuev)

# COMMAND ----------

# MAGIC %md **8. Obtain a DataFrame containing, for the customers who already existed in the previous month and are still active this month, 3 columns: name, age, n_days_without_sms. The last column refers to getting the number of times each customer has NOT sent any SMS in the month of August. Force the "show" command to display 30 values.** </br>
# MAGIC
# MAGIC (If in the entire month the customer "A" did not send any SMS for 3 days in the whole month, this column should contain the value 3. If there were any customers who had sent at least 1 SMS every day of the month, they will have a value of 0 in this column).

# COMMAND ----------

df_facturas_mes_ant = spark.read.table("df_facturas_mes_ant")
df_facturas_mes_actual = spark.read.table("df_facturas_mes_actual")
df_consumos_diarios = spark.read.table("df_consumos_diarios")
df_clientes = spark.read.table("df_clientes")

# Obtengo un DF igual que 'df_facturas_mes_actual' pero solo con los clientes que no son nuevos:
df_facturas_mes_actual_cons = (
    df_facturas_mes_actual.join(df_facturas_mes_ant, ["id_cliente"])
    .select("id_cliente")
    .dropDuplicates()
)

# Obtengo el DF 'df_consumos_diarios' pero solo con los clientes que no son nuevos, solo muestro las columnas "id_cliente", "sms_enviados", "fecha":
df_consumos_diarios_sms = df_consumos_diarios.select(
    "id_cliente", "sms_enviados", "fecha"
).join(df_facturas_mes_actual_cons, "id_cliente")

# Ahora, del DF anterior, selecciono solo los que tengan el valor de 'sms_enviados' en 0:
df_consumos_diarios_sms = df_consumos_diarios_sms.filter(col("sms_enviados") == 0)

# Agrupo por cliente y cuento en cuantos registros aparece cada ic_cliente (es decir, cuantos dias ha enviado 0 sms cada cliente):
df_consumos_diarios_sms = (
    df_consumos_diarios_sms.groupBy("id_cliente")
    .agg(count("id_cliente").alias("dias_sin_sms"))
    .join(df_clientes.select("id_cliente", "edad"), "id_cliente")
    .orderBy("id_cliente")
)

# Finalmente, muestro la columna 'nombre' y elimino la columna 'id_cliente':
df_consumos_diarios_sms = df_consumos_diarios_sms.join(
    df_clientes.select("id_cliente", "nombre"), "id_cliente"
).select("nombre", "edad", "dias_sin_sms")

df_consumos_diarios_sms.show(n=30)

# COMMAND ----------

# MAGIC %md **9. We want to obtain a Weighting Coefficient that allows us to evaluate each customer based on their consumption to identify the most attractive customers who are part of our company. THIS CALCULATION WILL ONLY BE MADE FOR CUSTOMERS WHO HAVE A SINGLE OFFER CONTRACTED WITH THE COMPANY. </br> This coefficient will be obtained based on daily consumption, and therefore only customers existing in the month of August will be considered, as we do not have consumption data for the month of July. </br> The weights assigned to each type of consumption are as follows:** 
# MAGIC
# MAGIC - 0.4 --> Mobile phone calls.
# MAGIC - 0.3 --> Mobile data (MB).
# MAGIC - 0.2 --> Landline calls.
# MAGIC - 0.1 --> SMS sent.

# COMMAND ----------

# MAGIC %md **The steps to follow are as follows:**
# MAGIC
# MAGIC 1. Obtain the sum of all days for each of the 4 consumptions for each client.<br>
# MAGIC <span style="color: red;">That is, calculate for each client, the sum of the 4 indicators throughout the entire month.</span>
# MAGIC
# MAGIC 2. Obtain the maximum of the previous calculation for all clients in order to obtain a value between 0 and 1 for each of the 4 consumptions (remember that this only applies to clients with ONLY ONE CONTRACTED OFFER in the month of August. The client with the highest data consumption will have a value of 1 in the 'mobile_data_0_1' column)<br>
# MAGIC <span style="color: red;">Steps:<br>- find the client with the largest 'total_data' -> mobile_data_0_1 = 1 <br>- the client with the largest 'total_sms' -> sms_0_1 = 1 <br>- the client with the largest 'total_mobile_calls' -> mobile_calls_0_1 = 1 <br>- the client with the largest 'total_landline_calls' -> landline_calls_0_1 = 1.<br>
# MAGIC The value of 'mobile_data_0_1', 'sms_0_1', 'total_mobile_calls', and 'landline_calls_0_1' that are not 1 will be a number between 0 and 1 representing the proportion.</span>
# MAGIC
# MAGIC 3. Multiply these obtained columns with values between 0 and 1 by their corresponding weighting (for example, the "mobile_data_0_1" column will be multiplied by the mobile data weighting of 0.4).
# MAGIC
# MAGIC 4. Finally, calculate the sum of the 4 obtained weights to calculate the desired weighting coefficient (client_coefficient), rounded to 3 decimals.
# MAGIC
# MAGIC 5. Display the resulting DF sorted by this coefficient in descending order, so that the first record corresponds to the most attractive client. The resulting DF will have 3 columns: name, age, client_coefficient.

# COMMAND ----------

df_facturas_mes_ant = spark.read.table("df_facturas_mes_ant")
df_facturas_mes_actual = spark.read.table("df_facturas_mes_actual")
df_consumos_diarios = spark.read.table("df_consumos_diarios")
df_clientes = spark.read.table("df_clientes")

# Obtenemos los clientes que tienen solo una oferta contratada en la compañía el mes de agosto:
df_facturas_mes_actual_aux = df_facturas_mes_actual.groupBy("id_cliente").agg(count("id_oferta").alias("num_contratos")).filter(col("num_contratos")==1).select("id_cliente").orderBy("id_cliente")
window = Window.partitionBy("group_by_col")

# 1. Obtenemos la suma de todos los dias de cada uno de los 4 consumos para cada uno de los clientes obtenidos en en el DF anterior:
df_consumos_diarios_aux = df_consumos_diarios.join(df_facturas_mes_actual_aux, "id_cliente") \
    .groupBy("id_cliente") \
    .agg( \
        sum("consumo_datos_MB").alias("total_datos"), \
        sum("sms_enviados").alias("total_sms"), \
        sum("minutos_llamadas_movil").alias("total_llamadas_movil"), \
        sum("minutos_llamadas_fijo").alias("total_llamadas_fijo")).orderBy("id_cliente")
# 2. Al DF anterior, creo las nuevas columnas 'datos_moviles_0_1', 'sms_0_1', 'total_llamadas_movil' y 'llamadas_fijo_0_1'
# Creo una columna 'dummy' con valor '1' que utilizaré para agrupar por esa misma columna y poder calcular el valor máximo de los 4 indicadores:
df_consumos_diarios_aux = df_consumos_diarios_aux.withColumn("group_by_col", lit(1))

# Creo 4 columnas que contengan el valor máximo de cada uno de los 4 indicadores:
df_consumos_diarios_aux = df_consumos_diarios_aux \
.withColumn("datos_max", max("total_datos").over(window)) \
.withColumn("sms_max", max("total_sms").over(window)) \
.withColumn("movil_max", max("total_llamadas_movil").over(window)) \
.withColumn("fijo_max", max("total_llamadas_fijo").over(window))

# Creo las 4 columnas 'datos_moviles_0_1', 'sms_0_1', 'llamadas_movil_0_1' y 'llamadas_fijo_0_1' y doy valor '1' y calculo el tanto por 1:
df_consumos_diarios_aux = df_consumos_diarios_aux \
.withColumn("datos_moviles_0_1", (col("total_datos")/col("datos_max"))) \
.withColumn("sms_0_1", (col("total_sms")/col("sms_max"))) \
.withColumn("llamadas_movil_0_1", (col("total_llamadas_movil")/col("movil_max"))) \
.withColumn("llamadas_fijo_0_1", (col("total_llamadas_fijo")/col("fijo_max"))) 

# 3. Multiplico por la ponderación correspondiente: 
df_consumos_diarios_aux = df_consumos_diarios_aux \
.withColumn("datos_moviles_0_1", col("datos_moviles_0_1")*.3 ) \
.withColumn("sms_0_1", col("sms_0_1")*.1 ) \
.withColumn("llamadas_movil_0_1", col("llamadas_movil_0_1")*.4 ) \
.withColumn("llamadas_fijo_0_1", col("llamadas_fijo_0_1")*.2 ) \

# 4. Obtengo la suma de los tres coeficientes: 
df_consumos_diarios_aux = df_consumos_diarios_aux \
.withColumn("coeficiente_cliente", (col("datos_moviles_0_1") + col("sms_0_1") + col("llamadas_movil_0_1") + col("llamadas_fijo_0_1")).cast(DecimalType(17,2))) 

# 5. Muestro el DF:
# Obtengo los nombres y edades y me quedo solo con las tres columnas que me piden:
df_consumos_diarios_aux = df_consumos_diarios_aux.join(df_clientes, "id_cliente").select("nombre", "edad", "coeficiente_cliente").orderBy(desc("coeficiente_cliente"))
display(df_consumos_diarios_aux)

# COMMAND ----------

# MAGIC %md **10. We want to find out the date on which, among the top 3 data consumers in each age group, they collectively reach a consumption of 20 GB of mobile data. If any age group does not reach 20 GB among the top 3 clients throughout the month, "null" will be assigned as the value for this column (Remember that 1 GB = 1024 MB).** </br> Obtain a DataFrame containing 4 records, one for each age group, and 3 columns: age_group, date_20_GB, total_mobile_data_group_3_clients. (total_mobile_data_group_3_clients represents the total data consumed in MB by the 3 clients in the group until the end of the month)

# COMMAND ----------

df_facturas_mes_ant = spark.read.table("df_facturas_mes_ant")
df_facturas_mes_actual = spark.read.table("df_facturas_mes_actual")
df_consumos_diarios = spark.read.table("df_consumos_diarios")
df_clientes = spark.read.table("df_clientes")
window_grupo_edad = Window.partitionBy("grupo_edad").orderBy(asc("fecha"), desc("consumo_datos_MB"))

# Hacemos que el DF df_clientes tenga la columna 'grupo_edad'
df_clientes = df_clientes.withColumn("grupo_edad", when(col("edad") < 26, lit(1))
                                         .when(col("edad").between(26,40),lit(2))
                                         .when(col("edad").between(41,65),lit(3))
                                         .otherwise(lit(4))).select("id_cliente", "nombre", "grupo_edad")
# Creo DF que contenga el ID y el grupo edad de los 3 clientes que mas datos moviles consumen de cada grupo edad:
df_cli_que_mas_consumen = df_consumos_diarios.select("id_cliente", "consumo_datos_MB", "fecha").join(df_clientes, "id_cliente").orderBy("id_cliente", "grupo_edad") \
    .groupBy("id_cliente") \
    .agg(sum("consumo_datos_MB").alias("total_datos"), \
        max("grupo_edad").alias("grupo_edad")).orderBy("id_cliente")
# Creo DF con los tres clientes que mas datos gastan del grupo edad 1
df_cli_que_mas_consumen_1 = df_cli_que_mas_consumen.filter(col("grupo_edad") == 1).orderBy(desc("total_datos")).limit(3)
# Creo DF con los tres clientes que mas datos gastan del grupo edad 2
df_cli_que_mas_consumen_2 = df_cli_que_mas_consumen.filter(col("grupo_edad") == 2).orderBy(desc("total_datos")).limit(3)
# Creo DF con los tres clientes que mas datos gastan del grupo edad 3
df_cli_que_mas_consumen_3 = df_cli_que_mas_consumen.filter(col("grupo_edad") == 3).orderBy(desc("total_datos")).limit(3)
# Creo DF con los tres clientes que mas datos gastan del grupo edad 4
df_cli_que_mas_consumen_4 = df_cli_que_mas_consumen.filter(col("grupo_edad") == 4).orderBy(desc("total_datos")).limit(3)
# Creo la columna que tiene la suma de los datos acomulados
df_cli_que_mas_consumen_grp = df_cli_que_mas_consumen_1.union(df_cli_que_mas_consumen_2).union(df_cli_que_mas_consumen_3).union(df_cli_que_mas_consumen_4).select("id_cliente", "grupo_edad")

df_res_1 = df_consumos_diarios.join(df_cli_que_mas_consumen_1, "id_cliente") \
    .withColumn("MB_ACUMULADAS", sum("consumo_datos_MB").over(window_grupo_edad.rowsBetween(Window.unboundedPreceding, Window.currentRow))) \
    .withColumn("MAX_MB", sum("consumo_datos_MB").over(window_grupo_edad.rowsBetween(Window.unboundedPreceding, Window.unboundedFollowing))) \
        .select("id_cliente", "consumo_datos_MB", "MB_ACUMULADAS", "fecha", "grupo_edad", "MAX_MB") \
    .orderBy("grupo_edad", "fecha") \
    .withColumn("alcanza_20", when(col("MB_ACUMULADAS") >= 1024 * 20, lit(1)).otherwise(lit(0))) \
    .filter(col("alcanza_20") == 1) \
    .limit(1)

df_res_2 = df_consumos_diarios.join(df_cli_que_mas_consumen_2, "id_cliente") \
    .withColumn("MB_ACUMULADAS", sum("consumo_datos_MB").over(window_grupo_edad.rowsBetween(Window.unboundedPreceding, Window.currentRow))) \
    .withColumn("MAX_MB", sum("consumo_datos_MB").over(window_grupo_edad.rowsBetween(Window.unboundedPreceding, Window.unboundedFollowing))) \
        .select("id_cliente", "consumo_datos_MB", "MB_ACUMULADAS", "fecha", "grupo_edad", "MAX_MB") \
    .orderBy("grupo_edad", "fecha") \
    .withColumn("alcanza_20", when(col("MB_ACUMULADAS") >= 1024 * 20, lit(1)).otherwise(lit(0))) \
    .filter(col("alcanza_20") == 1) \
    .limit(1)

df_res_3 = df_consumos_diarios.join(df_cli_que_mas_consumen_3, "id_cliente") \
    .withColumn("MB_ACUMULADAS", sum("consumo_datos_MB").over(window_grupo_edad.rowsBetween(Window.unboundedPreceding, Window.currentRow))) \
    .withColumn("MAX_MB", sum("consumo_datos_MB").over(window_grupo_edad.rowsBetween(Window.unboundedPreceding, Window.unboundedFollowing))) \
        .select("id_cliente", "consumo_datos_MB", "MB_ACUMULADAS", "fecha", "grupo_edad", "MAX_MB") \
    .orderBy("grupo_edad", "fecha") \
    .withColumn("alcanza_20", when(col("MB_ACUMULADAS") >= 1024 * 20, lit(1)).otherwise(lit(0))) \
    .filter((col("alcanza_20") == 1) | (col("MAX_MB") <1024 * 20 )) \
    .limit(1)

df_res_4 = df_consumos_diarios.join(df_cli_que_mas_consumen_4, "id_cliente") \
    .withColumn("MB_ACUMULADAS", sum("consumo_datos_MB").over(window_grupo_edad.rowsBetween(Window.unboundedPreceding, Window.currentRow))) \
    .withColumn("MAX_MB", sum("consumo_datos_MB").over(window_grupo_edad.rowsBetween(Window.unboundedPreceding, Window.unboundedFollowing))) \
        .select("id_cliente", "consumo_datos_MB", "MB_ACUMULADAS", "fecha", "grupo_edad", "MAX_MB") \
    .orderBy("grupo_edad", "fecha") \
    .withColumn("alcanza_20", when(col("MB_ACUMULADAS") >= 1024 * 20, lit(1)).otherwise(lit(0))) \
    .filter((col("alcanza_20") == 1) | (col("MAX_MB") <1024 * 20 )) \
    .limit(1)
    
df_res = df_res_1.union(df_res_2).union(df_res_3).union(df_res_4) \
    .select("grupo_edad", "fecha", "MAX_MB", "alcanza_20") \
    .withColumnRenamed("fecha", "fecha_20_GB") \
    .withColumnRenamed("MAX_MB", "datos_moviles_total_grupo_3_clientes") \
    .withColumn("fecha_20_GB", when(col("alcanza_20") == lit(0), lit(None)).otherwise(col("fecha_20_GB"))) \
    .select("grupo_edad", "fecha_20_GB", "datos_moviles_total_grupo_3_clientes") 

display(df_res)

# COMMAND ----------


